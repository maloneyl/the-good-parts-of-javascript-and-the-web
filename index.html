<!DOCTYPE html>
<html>
<head>
  <title>Fun with Functions</title>
</head>
<body>
  <pre>
    <script>
      function log(arg) {
        document.writeln(arg);
      }

      function identity(x) {
        return x;
      }
      // log(identity(3));

      function add(first, second) {
        return first + second;
      }

      function sub(first, second) {
        return first - second;
      }

      function mul(first, second) {
        return first * second;
      }

      // log(add(3, 4));
      // log(sub(3, 4));
      // log(mul(3, 4));

      function identityf(x) {
        return function() {
          return x;
        }
      }
      // var three = identityf(3);
      // log(three());

      // Write a function addf that adds from two invocations.
      function addf(first) {
        return function (second) {
          return first + second;
        }
      }
      // log(addf(3)(4));

      // Write a function liftf that takes a binary function,
      // and makes it callable with two invocations.
      // Higher-order functions: receive other functions as parameters,
      // and return other functions as results.
      function liftf(binaryFunc) {
        return function (first) {
          return function (second) {
            return binaryFunc(first, second);
          }
        }
      }
      // var addf = liftf(add);
      // log(addf(3)(4));
      // log(liftf(mul)(5)(6));

      // Write a function curry that takes a binary function as an argument,
      // and return a function that can take a second argument.
      function curry(binaryFunc, first) {
        return function (second) {
          return binaryFunc(first, second);
        }
        // alternative: use liftf
        //   return liftf(binaryFunc)(first);
      }
      // var add3 = curry(add, 3);
      // log(add3(4));
      // log(curry(mul, 5)(6));
      // Curry was a mathematician who did a lot of work with Church's lambda calculus.
      // By normalizing all functions to take only one argument,
      // it made a lot of operations easier to think about.

      // Without writing any new functions,
      // show three ways to create the inc function.
      var inc = curry(add, 1);
      var inc = liftf(add)(1);
      var inc = addf(1);
      // log(inc(5));
      // log(inc(inc(5)));
      // First rule of functional programming: let the functions do the work.
      // If you've already written a function that does what you need, you don't need to write another one.

      // Write a function twice that takes a binary function
      // and returns a unary function
      // that passes its argument to the binary function twice,
      // e.g. doubl = twice(add); square = twice(mul);
      function twice(binaryFunc) {
        return function (x) {
          return binaryFunc(x, x)
        }
      }
      var doubl = twice(add);
      // log(doubl(11));
      var square = twice(mul);
      // log(square(11));

      // Write reverse, a function that reverses
      // the arguments of a binary function.
      function reverse(binaryFunc) {
        return function (first, second) {
          return binaryFunc(second, first);
        }
      }
      // with ES6 and for any number of arguments:
      // function reverse(func) {
      //   return function(...args) {
      //     return func(...args.reverse());
      //   }
      // }
      var bus = reverse(sub);
      // log(bus(3, 2)); // -1

      // Write a function composeu that takes two unary functions
      // and returns a unary function that calls them both,
      function composeu(func1, func2) {
        return function (x) {
          return func2(func1(x));
        }
      }
      // log(composeu(doubl, square)(5)); // (5+5)^2 = 100

      // Write a function composeb that takes two binary functions
      // and returns a function that calls them both.
      function composeb(binaryFunc1, binaryFunc2) {
        return function (x, y, z) {
          return binaryFunc2(binaryFunc1(x, y), z);
        }
      }
      // log(composeb(add, mul)(2, 3, 7)); // (2+3) *  7 = 35

      // Write a limit function that allows a binary function
      // to be called a limited number of times.
      function limit(binaryFunc, count) {
        return function (x, y) {
          if (count >= 1) {
            count -= 1;
            return binaryFunc(x, y)
          }
          return undefined; // explicitly document the behavior
        }
      }
      var add_ltd = limit(add, 2);
      // log(add_ltd(3, 4)); // 7
      // log(add_ltd(3, 5)); // 8
      // log(add_ltd(3, 6)); // undefined

      // Write a from function that produces a generator
      // that will produce a series of values.
      function from(x) {
        return function () {
          var count = x;
          x += 1;
          return count;
        }
      }
      var index = from(0);
      // log(index()); // 0
      // log(index()); // 1
      // log(index()); // 2

      // Write a to function that takes a generator and an end value,
      // and returns a generator that will produce numbers up to that limit.
      function to(generator, endValue) {
        return function () {
          var value = generator();
          if (value < endValue) {
            return value;
          } else {
            return undefined;
          }
        }
      }
      var index = to(from(1), 3);
      // log(index()); // 1
      // log(index()); // 2
      // log(index()); // undefined

      // Write a fromTo function that produces a generator
      // that will produce values in a range.
      function fromTo(startValue, endValue) {
        return to(from(startValue), endValue);
      }
      var index = fromTo(0, 3);
      // log(index()); // 0
      // log(index()); // 1
      // log(index()); // 2
      // log(index()); // undefined

      // Write an element function that takes an array and a generator
      // and returns a generator that will produce elements from the array.
      function element(arr, generator) {
        return function () {
          var index = generator();
          if (index !== undefined) {
            return arr[index];
          }
        }
      }
      var ele = element(['a', 'b', 'c', 'd'], fromTo(1, 3));
      // log(ele()); // 'b'
      // log(ele()); // 'c'
      // log(ele()); // undefined

      // Modify the element function so that the generator argument is optional.
      // If a generator is not provided, then each of the elements of the array will be produced.
      function element(arr, generator) { // ES6: generator = fromTo(...)
        if (generator === undefined) {
          generator = fromTo(0, arr.length);
        }
        return function () {
          var index = generator();
          if (index !== undefined) {
            return arr[index];
          }
        }
      }
      var ele = element(['a', 'b', 'c', 'd']);
      log(ele()); // 'a'
      log(ele()); // 'b'
      log(ele()); // 'c'
      log(ele()); // 'd'
      log(ele()); // undefined
    </script>
  </pre>
</body>
</html>
